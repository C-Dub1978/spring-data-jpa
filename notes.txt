@NamedQuery - used to create NON native sql queries using JPQL
@NamedQueries - hash of multiple @NamedQuery (you cant add multiple @NamedQuery annotations to
a class, you must wrap in @NamedQueries({ value = {
    @NameQuery(........)
}}))

These will be added to the actual Entity class. They can be parameterized with named (:paramName) or
positional (1?)

Heres how to deal with parameters

1. set it (positional params)
Query query = em.createNativeQuery("SELECT * FROM COURSE WHERE id = ?", Course.class);
// The first parameter is positional, so if you had a more complex query with multiple params,
// you could just continue to set the parameters as many times as needed - I.E.

Query query = em.createNativeQuery(
    "SELECT * FROM COURSE WHERE id = ?1 AND name = ?2"
)
query.setParameter(1, 1001L).setParameter(2, "course name");
query.getResultList();

2. set it (named params)
Query query = em.createNativeQuery("SELECT * FROM COURSE WHERE id = :id AND name = :name);
query.setParameter("id", 1001L).setParameter("name", "Some Name to Query");

Keep in mind - there are only sometimes that you have to used native queries instead of JPQL - 
one of those instances is if you are doing a MASS update on a bunch of records. If you want to use JPA, you'd have to 1. get the row, update it. Get the next row, update it.....
this would take forever and would be highly inefficient

REMEMBER - IF YOU ARE USING NATIVE QUERIES, YOU ARE NOT MAKING USE OF PERSISTENCE CONTEXT SO BE AWARE,
YOU NEED TO MANUALLY REFRESH AND TRACK

=============================================

JPA relationships

In our upcoming refactors, we will soon have the following entities:
Course
Student
SchoolIdentification
CourseReview
Grade

@ManyToMany
Course <---> Student (a course can have many students enrolled, and a student can be enrolled in many courses)

@OneToOne
Student <---> Identification (a student can have ONE school identification card, and a card can only be associated with 1 student)

@ManyToOne
Course <---> CourseReview
A Course can have multiple CourseReviews. However, a CourseReview, can only be associated with a single course.
(We are looking at this from the CourseReview perspective, its @ManyToOne - meaning that many CourseReviews can be associated with a single Course)
(If we look at it from the Course perspective, we can define it as @OneToMany, being that ONE single course can have many reviews)


@OneToOne details
****** IMPORTANT ********
ONE TO ONE RELATIONSHIPS BY DEFAULT ARE ALWAYS EAGERLY FETCHED - 
you can also convert this to LAZY fetching as well, tbd...

In our case (learning, not real world), a student can only have 1 address. We
cant associated a student with multiple addresses. So for the relationship, we can
say that:

Student <----> Address is a OneToOne relationship. To define this, lets think about
sql first - we can say that a Student object can have a field which has a foreign
key mapped to an Address instance (which is the primary key of the Address).
OR, the other way around, we can say an Address
instance can be mapped to a foreign key of a Student (with student primary key being
the foreign key)

So basically in a 1 to 1, you can declare inside the student class, a
@OneToOne
private Adress adress;

OR

you can declare inside the address class, a
@OneToOne
private Student student;

wherever you choose to define a @OneToOne, you can say that inside that entity,
its OWNS the relationship for a 1 to 1, it does NOT have to be a 2 way relation

Lazy vs Eager -
By deafult if you do not annotate an entity field which has a relationship,
with a fetch strategy, its gonna try to EAGER fetch.

so If we look at our Student (or Address class), simply add @OneToOne(fetch=FetchType.LAZY)
Keep in mind, doing it this way - when we search for a student for example, like
Student testStudent = em.find(Student.class, 10L);
// ERROR ON THE NEXT LINE
Address address = student.getAddress() # <------ Exception thrown
// To avoid this, make sure any method that is trying to retrieve a Student and then trying to get its
// Address in the same trasaction, make sure the method is marked with @Transactional

Lazy fetching ONLY gets relationship objects from one specific object type when you specifically
ASK for those relationship object

//////////// HUGE ISSUE - IF YOU ARE USING ENTITY MANAGER, AND ARE FUCKING WITH THINGS
INSIDE A METHOD - LETS SAY YOU HAVE A CHAIN OF DB CALLS -

public void entityWeirdness() {
    Student student = this.em.find(Student.class, 12L); // touching the database 1, em is tracking
    student.setFirsttName("Chris");
    student.setLasttName("Chelios");

    // WE ARE STILL WITHIN THE ENTITYMANAGER CONTEXT AND STUFF WILL PERSIST
    // UNLESS FOR SOME REASON SOMETHING FUCKING FAILS - IF WE DONT ANNOTATE THE ABOVE
    // METHOD WITH @TRANSACTIONAL, if the call to student.setLastName fails, youre going
    // to fuck your databse up.
}

BOOOOOM! If the above line getting the address fails, if we mark it with @Transactional,
then once the address 'get' line failse, we roll the whole transaction back and we dont
fuck the database

Moral of the story is mark the methods that are manipluation data with @Transactional

As soon as you define somthing with @Transactional, inside youre methods, you are
dealing with the exact moment that involves the persistence context

At the end of the day - if you are using entityManager -
if you call a method thats not annotated with @Transactional

public void entityWeirdness() {
    Object myObject = em.findSomethingById(1L);
    object.setSomeProperty("exception thrown"); <======= BOOOM we have not annotated with @Transactional
    // so the line above me will fail

}

====================================================

@OneToOne - bidirectional relationships
The way we have it, we have annotated our Student entity so far with a @OnetoOne on its
Address and StudentGrade fields. With JUST that annotation, we can get a student object,
then from it call student.getAddress() or student.getStudentGrade(). 

Shouldnt we be able to do the opposite? 

Yes! We should be able to retrieve an Address or StudentGrade entity from the db, and from either
call entity.getStudent()

As long as we annotate both the Address and StudentGrade entities with a @OneToOne with its Student
field, we can then get the Student entity from either of those. If we DONT annotate the Address
and Student entities, we will not be able to get the Student from either.
IMPORTANT!
If we just set this up as above, the student table will now have 2 new fields - address_id and
student_grade_id
Both the address and student_grade tables will also have a new field, student_id.
This is BAD, we are storing duplicate data in these fields, so in order to keep things clean
in the DB, we need to specify an "Owning" side of the @OneToOne

Pick which entity you want to be the owner (student -> address), (student -> studentGrade), or vice
versa. We will choose to have the student entity be the owner, so we must add the following to
the @OneToOne in both the Address and StudentGrade entities:
@OneToOne(fetch=FetchType.LAZY, mappedBy="student") <- student is the actual field name....

(remember, you add the mappedBy="" to the NON owning side, not the other way around)